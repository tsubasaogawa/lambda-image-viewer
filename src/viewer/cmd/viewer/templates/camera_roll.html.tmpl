<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Camera Roll</title>
    <link href="https://fonts.googleapis.com/css?family=Open+Sans" rel="stylesheet">
    <style media="screen">
      /* General Body Styles */
      body {
        margin: 0;
        padding: 80px;
        font-family: 'Open Sans', sans-serif;
      }

      /* Thumbnail Box Styles */
      .thumbnailBox {
        position: relative;
      }

      .thumbnailBox button {
        position: absolute;
        right: 0;
        top: 0;
        display: none; /* Hidden by default */
      }

      .thumbnailBox:hover button {
        display: block; /* Visible on hover */
      }

      /* Cameraroll Grid Styles */
      #cameraroll-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(150px, 1fr)); /* Default column size */
        gap: 5px;
        padding: 10px;
      }

      /* Responsive adjustments for cameraroll grid */
      @media (min-width: 600px) {
        #cameraroll-grid {
          grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        }
      }

      @media (min-width: 900px) {
        #cameraroll-grid {
          grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
        }
      }

      /* Month Header Styles */
      h2.month-header {
        grid-column: 1 / -1; /* Span across all columns */
        text-align: left;
        margin: 20px 0 10px 0;
        color: #333;
        font-size: 1.8em;
      }

      /* Loader Styles */
      #loader {
        text-align: center;
        padding: 20px;
        grid-column: 1 / -1; /* Span across all columns */
      }
    </style>
  </head>
  <body>
    <h1>Camera Roll</h1>
    {{ $origin := .OriginDomain }}
    {{ $viewer := .ViewerDomain }}
    {{ $isPrivate := .IsPrivate }}
    <div id="cameraroll-grid">
    </div>
    <div id="loader" style="display: none;">Loading...</div>
    <p>
      <a href="/cameraroll/">Home</a>
    </p>
    <p id="private_mode">
      <input type="checkbox" id="privateModeCheckbox"> Switch to private mode
    </p>
    <p id="copyinfo">
      Copy the HTML tag to clipboard by clicking the ðŸ“‹ button.
    </p>
    <script src="https://{{ $origin }}/assets/generate_access_token.js"></script>
    <script>
      const salt = "{{ .SaltForPrivateImage }}";
      let lastEvaluatedKey = "{{ .LastKey }}";
      let isLoading = false;
      const THUMBNAIL_WIDTH = 133;
      const THUMBNAIL_HEIGHT = 133;
      const SCROLL_THRESHOLD = 500; // Pixels from the bottom to trigger loading
      const camerarollGrid = document.getElementById('cameraroll-grid');
      const loader = document.getElementById('loader');
      let lastMonth = "";

      // Check the checkbox if 'private=true' is already in the URL
      const urlParams = new URLSearchParams(window.location.search);
      const isPrivate = urlParams.has('private') && urlParams.get('private') === 'true';

      function copy(key, w, h) {
        const tag = '<img class="load-exif" src="https://{{ $origin }}/' + key + '" width="' + w + '" height="' + h + '" loading="lazy">';
        navigator.clipboard.writeText(tag);
      }

      const privateModeCheckbox = document.getElementById('privateModeCheckbox');

      function initializePrivateModeCheckbox() {
        if (isPrivate) {
          privateModeCheckbox.checked = true;
        }
        privateModeCheckbox.addEventListener('change', function() {
          const currentUrl = new URL(window.location.href);
          currentUrl.pathname = '/cameraroll/';
          currentUrl.search = '';
          if (this.checked) {
            currentUrl.searchParams.set('private', 'true');
          }
          window.location.href = currentUrl.toString();
        });
      }

      const initialThumbnailsData = [
        {{ range $i, $thumb := .Thumbnails }}
          {{ if or (and $isPrivate $thumb.Private) (and (not $isPrivate) (not $thumb.Private)) }}
            {
              id: "{{ $thumb.Id }}",
              timestamp: {{ $thumb.Timestamp }},
              private: {{ $thumb.Private }},
              width: {{ $thumb.Width }},
              height: {{ $thumb.Height }}
            },
          {{ end }}
        {{ end }}
      ];

      function groupThumbnailsByMonth(thumbnails) {
        return thumbnails.reduce((groups, thumb) => {
          const timestamp = thumb.timestamp;
          let key;
          if (timestamp) {
            const date = new Date(timestamp * 1000);
            const year = date.getFullYear();
            const month = (date.getMonth() + 1).toString().padStart(2, '0');
            key = `${year}-${month}`;
          } else {
            key = "Undefined";
          }

          if (!groups[key]) {
            groups[key] = [];
          }
          groups[key].push(thumb);
          return groups;
        }, {});
      }
      
      function createThumbnailElement(thumb) {
        const thumbnailBox = document.createElement('div');
        thumbnailBox.classList.add('thumbnailBox');
        thumbnailBox.id = thumb.timestamp;
        thumbnailBox.dataset.timestamp = thumb.timestamp;

        const link = document.createElement('a');
        link.href = `https://{{ $viewer }}/image/${thumb.id}`;

        const img = document.createElement('img');
        img.dataset.src = `https://{{ $origin }}/thumbnail/${thumb.id}`;
        img.width = THUMBNAIL_WIDTH;
        img.height = THUMBNAIL_HEIGHT;
        img.classList.add('thumbnailImage');
        img.dataset.private = thumb.private;
        img.loading = 'lazy';

        link.appendChild(img);
        thumbnailBox.appendChild(link);

        if (!thumb.private) {
          const copyButton = document.createElement('button');
          copyButton.textContent = 'ðŸ“‹';
          copyButton.onclick = () => copy(thumb.id, thumb.width, thumb.height);
          thumbnailBox.appendChild(copyButton);
        }
        return thumbnailBox;
      }

      function updateLoaderVisibility(visible, message = '') {
        loader.style.display = visible ? 'block' : 'none';
        loader.textContent = message || 'Loading...';
      }
      
      async function renderThumbnails(thumbnails) {
        const grouped = groupThumbnailsByMonth(thumbnails);
        const sortedKeys = Object.keys(grouped).sort((a, b) => {
            if (a === "Undefined") return 1;
            if (b === "Undefined") return -1;
            return b.localeCompare(a);
        });

        for (const month of sortedKeys) {
            if (month !== lastMonth) {
                const header = document.createElement('h2');
                header.classList.add('month-header');
                let date, year;
                if (month !== 'Undefined') {
                    const [yearStr, monthStr] = month.split('-');
                    date = new Date(parseInt(yearStr, 10), parseInt(monthStr, 10) - 1, 1);
                    year = yearStr;
                } else {
                    date = null;
                    year = '';
                }
                const monthName = date ? date.toLocaleString('en-US', { month: 'long' }) : 'Undefined';
                header.textContent = `${monthName}, ${year}`;
                camerarollGrid.appendChild(header);
                lastMonth = month;
            }

            for (const thumb of grouped[month]) {
                const thumbnailElement = createThumbnailElement(thumb);
                camerarollGrid.appendChild(thumbnailElement);
            }
        }
        await loadVisibleImages();
      }

      async function loadVisibleImages() {
          const images = document.querySelectorAll('img.thumbnailImage:not([src])');
          const imagePromises = [];
          for (const img of images) {
              if (isPrivate) {
                  const url = new URL(img.dataset.src);
                  const key = url.pathname;
                  const tokenPromise = generateToken(key, salt).then(token => {
                      const imageUrl = new URL(img.dataset.src);
                      imageUrl.searchParams.set('token', token);
                      img.src = imageUrl.toString();
                  });
                  imagePromises.push(tokenPromise);
              } else {
                  img.src = img.dataset.src;
              }
          }
          await Promise.all(imagePromises);
      }

      async function fetchMoreImages() {
        if (isLoading || !lastEvaluatedKey) return;

        isLoading = true;
        updateLoaderVisibility(true);

        try {
          const apiUrl = new URL(window.location.href);
          apiUrl.search = ''; // Clear existing params
          apiUrl.searchParams.set('last_evaluated_key', lastEvaluatedKey);
          if (isPrivate) {
            apiUrl.searchParams.set('private', 'true');
          }

          const response = await fetch(apiUrl);
          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }
          const data = await response.json();

          const filteredThumbnails = data.thumbnails.filter(thumb => {
            return isPrivate ? thumb.private : !thumb.private;
          });

          await renderThumbnails(filteredThumbnails);
          
          lastEvaluatedKey = data.last_evaluated_key;
          if (!lastEvaluatedKey) {
            updateLoaderVisibility(true, 'No more images.');
          }
        } catch (error) {
          console.error('Failed to fetch more images:', error);
          updateLoaderVisibility(true, 'Failed to load images. Please try again later.');
        } finally {
          isLoading = false;
          if (lastEvaluatedKey) {
            updateLoaderVisibility(false);
          }
        }
      }

      window.addEventListener('scroll', () => {
        if ((window.innerHeight + window.scrollY) >= document.body.offsetHeight - SCROLL_THRESHOLD) {
          fetchMoreImages();
        }
      });

      document.addEventListener('DOMContentLoaded', async function() {
        initializePrivateModeCheckbox();
        await renderThumbnails(initialThumbnailsData);
      });
    </script>
  </body>
</html>
